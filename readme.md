
##2024-12-13
后端使用hutool生成验证码base64传到前端，并将验证码的答案以（k:验证码哈希值，v：验证码答案）存到redis中，过期时间为2分钟。用户拿到验证码图案后，输入邮箱和验证码答案，点击发送，请求送到后端，在判断邮箱格式合法并且对应的验证码正确后，将验证码发送任务提交到线程池并返回成功。线程池收到任务后使用JavaMailSender发送邮箱验证码并将验证码存储到redis（5分钟过期时间）。用户在输入所有字段后进行注册，首先判断用户输入的邮箱经过了验证（redis取出相应邮箱验证码与传入的邮箱验证码字段比较），然后将密码利用BCryptEncoder加密后将所有字段持久化到数据库。

2024-12-15
* 抽取邮箱验证码发送逻辑，封装验证码发送和验证码验证为service，供用户注册和账号找回等service使用
* 完成账户找回和用户登录，对于用户找回，首先验证邮箱验证码与邮箱的匹配，然后验证账户与邮箱的匹配，最后执行密码更改逻辑。对于用户登录，使用spring security的authenticationManager验证密码与数据库中经过编码的密码是否一致，authenticationManager会调用我们实现的UserDetailsService得到封装用户信息的UserDetails得到用户名和密码，如果一致，生成一个新的jwt包含用户名和过期时间，作为响应返回。jwt和用户名返回后存储到session storage并在后续请求中authorization字段填充上jwt。后端springsecurity密码验证前加入一个jwt的过滤器，判断jwt信息是否合法。
* 主页面框架搭建，右上角在未登录时显示登录，跳转到登录页面，登录时显示用户头像和用户名。搭建minio存储头像文件
2024-12-16
* 用户头像修改：用户点击修改个人信息后显示个人信息修改页面。点击头像显示头像上传选项卡，上传文件后，预览图像会显示并显示上传按钮。点击上传后，头像以multipart file的形式发送到后端，后端使用@RequestParam获取MultiPartFile，雪花算法生成头像id防止重复，然后转成十六进制，multipart获取对应的FileInputStream使用MinioClient上传到Minio，查询用户先前的头像文件名，如果不为空则删除minio中对应的文件，然后将头像新文件的文件名更新。后端响应成功后前端调用重新加载用户信息函数从后端的/user接口获取更新后的用户信息，刷新上传后的用户头像。
*  用户名修改：在修改用户名后需要重新生成jwt并返回前端存储，因为我们需要前端传递的jwt中的user字段判断当前用户是谁，如果不同步更改jwt会导致后续请求查询到不存在的用户，进而导致所有查询语句为空
2024-12-17
* 抽取验证码图像的获取与验证逻辑为单独的controller和service，因为不仅登陆前注册、账户找回时需要，注册后进行邮箱更改时也需要，响应api的security访问策略需要为permitAll
* 修改邮箱：首先验证原邮箱的权限，验证成功后返回授权token标识用户和原邮箱，然后同样通过邮箱验证码验证新邮箱的权限，之后验证token的有效性以验证请求具有修改邮箱的权限，验证成功后修改邮箱。
2024-12-18
* 前端：用户输入地址信息，高德api查询候选项前端渲染，用户点击选择项，前端显示对应选项信息并将地图移动标点，用户点击修改信息后向后端发请求
* 后端：位置查询api：如果位置为空则字段设置为“未设置”后返回，如果user表的location_id不为空，则查询location表信息并返回。修改api，将查询user表获取先前user信息，将新位置插入location表，获取location id后修改user的location_id字段，如果先前location_id不为空则删除location表中对应行。由于涉及多次表的修改操作，service方法加@Transactional在失败时进行任务回滚。
2024-12-19
* 前端：使用高德地图api选择政区
2024-12-22
* 设备管理，允许添加删除设备，选择用户默认设备
* 前端：从后端加载用户呼号、设备信息、位置信息等内容填充表单并从高德api加载天气信息，地理位置可以随时修改，天气会同步更新。
2024-12-23
* 新建日志，数据库持久化 
2024-12-24
* 日志分页查询浏览及删除，由于浏览日志大部分是不需要点开看详细信息，且删除日志后会重新刷新页面概览数据，如果分页查询直接返回全量数据会造成大量流量的不必要消耗，因此分页查询仅返回概览数据，只有点击查看详情时才返回所有数据，减少流量消耗  5.93KB->2.07KB
* 手动确认日志功能，根据target_call_sign筛选未经确认的log返回，在展示详情和进行确认操作时，使用where语句确保target_call_sign是当前用户的call_sign防止未授权的操作。
2024-12-25
* 使用WebSocket和Redis实现新确认日志的通知，在用户插入一条日志后，会在另一线程调用通知逻辑：目标呼号redis待确认新日志记录器+1，websocket判断目标呼号用户是否活跃，如果活跃则发送ws信息，目标客户浏览器在收到消息后更新响应字段进行显示，用户点击待确认消息后向后端发送删除待确认新日志的请求将redis对应记录删除。在用户首次登陆后会查询redis中的新待确认日志数量并进行显示。
* 日志自动确认：日志在持久化到数据库后，提交异步任务到线程池：根据呼号和开始时间、结束时间查询当前匹配到的还未确认的日志，如果存在，选择开始时间最早的一条将其状态设置为已确认，同时该条日志的状态也设置成已确认。如果不存在，再执行websocket通知逻辑。
* 减小匹配开销：1.如果target_call_sign没有在系统中注册，那么就不会有可以匹配的日志，因此，在call_sign注册时存储到redisson管理的bloom filter中，在匹配时首先判断target_call_sign是否存在，只有存在时再进行匹配。
* 进一步减少匹配开销：很大一部分日志都会在当日匹配（双方边通联边提交，或者当日提交），因此可以判断log的开始时间距离当前时间是否在24小时内，如果在的话则查找redis有没有匹配的日志，如果没有，则放入redis等待匹配，只有一天之前的日志才直接进行数据库查找匹配。这里会检测前后共三分钟的差值，防止两个用户记录时间的些许不一致导致匹配失败。缓存过期时间设置为25小时，防止判断需要在缓存匹配，执行过程中目标日志过期被删除，则双方就没有匹配的机会了。 lua脚本保证操作的原子性
2024-12-26
* 使用ThreadLocal存储用户信息，防止重复查询数据库，并在封装返回信息的时候清除防止内存泄漏（同时考虑了正常情况和异常情况）。
* 发现附近的HAM：用户激活该功能后会在redis里的一个geo集合里存储他的地理位置，在选择距离并搜索后从geo里返回符合条件的用户集合返回前端展示
2024-12-27
* 附近的HAM时间匹配功能，在激活功能时同时上传在线的时间段，base64编码后存储到redis，在geo筛选完附近的人后进行时间匹配过滤，只有base64解码后的byte数组进行位操作不为0的值才进行返回。
2025-1-1
* 附近HAM功能：添加用户活跃时间的修改，目标用户活跃时间的显示与用户活跃时间的初始加载
* 统一websocket响应格式，方便后续发送多种消息，增加websocket鉴权逻辑，防止隐私泄露：设置authenticated字段，初始为false，前端在建立连接后需要发送自己sessionStorage存储的jwt token，后端收到后解析并判断对应用户的呼号是否与建立连接的呼号匹配，匹配后设置authenticated为true，只有鉴权后才允许后续消息的双向发送。
2025-1-2
* 聊天：对方在线状态显示：点击打开聊天后，前端向后端发送socket消息，标识目标用户，后端根据socket链接状态返回目标用户是否在线供前端显示。后端socket维护communicators集合，在用户连接关闭后，对communicators集合中的用户发送离线提醒，将他们前端中显示当前用户的状态为离线。
* 聊天发送：用户发送消息，后端收到消息后将消息存到redis方便后续查询，然后判断目标用户是否活跃并且目标用户打开的聊天窗口是否为当前用户，如果是则通过websocket发送实时消息，然后将消息存入消息队列，响应成功。消息队列消费者收到消息后将消息进行持久化并将其放入24h延时队列删除redis对应聊天集合中超过24小时的消息。
2025-1-3
* 聊天历史记录显示（缓存）：24小时内的消息是高频访问的，因此缓存在redis中，用户打开窗口时加载redis内存储的24小时内的聊天记录。在上滑到加载更多时再从数据库加载时间更早的聊天记录。
* 加载更早的聊天记录：用户划到最早的聊天记录后可以加载更早的聊天记录，发送请求中包含目标用户和时间戳，如果时间戳为空则从数据库中加载前50条符合条件的记录，否则加载从第一个在时间戳之前的记录开始的50条符合条件的记录。
2025-1-6
* 显示聊天对象列表：搜索发送者或接收者为用户的消息，按对象分组，按发送时间倒序排序，得到按最近沟通时间排序的用户列表
	![[Pasted image 20250106194619.png]]
* 聊天列表实时刷新：在发送或接收消息后，延迟一段时间刷新聊天列表，以按最新聊天情况排序 （存在问题：显示聊天对象列表的SQL语句延时肯定很高，频繁请求会导致数据库压力增加，如何解决？ 上述SQL语句加索引优化，降低请求频率如没间隔10s刷新一次而不是有消息就刷新） （o：存在问题：当前是前端判断1s后刷新，原因是数据库持久化是消息队列的消费者执行，存在延迟，可以改为消费者持久化后发送刷新通知，然后前端再请求，刷新列表）    ***待优化*
* 新消息通知：TAB栏显示有几个用户给发送了新消息，消息用户列表显示谁发了新消息，点击后红点消失，TAB栏提示数目减少。Redis维护以用户为KEY的集合，集合内存储给该用户发送消息的用户的呼号。后端处理发送新消息请求时，判断目标用户的激活窗口用户是否为当前用户，如果是则发送WS消息，如果不是则在Redis对应集合里添加该用户，并向目标用户发送WS新消息提醒（如果目标用户在线，注意这里并不冲突，即使用户在线，也并不一定打开了对于当前用户的聊天窗口）。前端收到WS新消息提醒后按消息中的基数更新TAB栏目并刷新聊天对象列表，显示哪个用户发送了新消息。 聊天对象列表：在从数据库查完后，redis加载对应新消息用户集合，按用户是否在集合内给每条数据的HasNewMessage字段赋值。
* **遇到的问题**：前端收到新消息提示后立即加载聊天对象列表发现加载的不是最新消息：原因是聊天数据的持久化是消息队列的消费者做的，存在延迟，因此收到消息后立即加载加载不到最新的数据，采取了类似o的做法，把新消息提示放在了消费者做，在持久化后再通过WS发送新消息提示。仍存在问题：消费者采用了Transactional注解，因此WS消息发送时事务并没提交，导致还拿不到新数据：把事务部分抽取出来，在事务提交之后再进行新消息提示。